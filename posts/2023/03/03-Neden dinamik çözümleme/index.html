<!DOCTYPE html>
<html>
    <head>
        <title>Erencan Ceyhan - Neden?: Dinamik Çözümleme</title>
        <meta charset="utf-8"/>
        <link rel="stylesheet" href="https://unpkg.com/98.css"/>
        <link rel="stylesheet" href="/navbar.css"/>
        <link rel="stylesheet" href="/posts/post.css" />
    </head>
    <body>
        <div>
            <nav>
                <a class="nav-link" href="/index.html"><button>Ana Sayfa</button></a>
                <a class="nav-link" href="/posts/posts.html"><button>Gönderiler</button></a>
                <a class="nav-link" href="/about.html"><button>Hakkımda</button></a>
            </nav>
        </div>
        <hr/>
        <header>
            <a class="nav-link" href="../02-Kut Dili/index.html"><button>Önceki</button></a>
        </header>
        <div>
            <h3>Neden?: Dinamik Çözümleme</h3>
            <p>Üçüncü gönderi ile hepinize merhaba! Kut'un çalışan ilk derlemesini almanın mutluluğu ile kendimi yeni bir gönderi yazarken buldum. Elimdeki derleyici/yorumlayıcı kombinasyonunun en azından bir listenin içinde dönebildiğini görmek sevinç kaynağı oldu benim için. Bu sırada üst fonksiyonlardan değişken alabilmesi, ve bütün bunları adres ve hafıza arındırıcılardan (sanitizer) sorunsuz geçerek yapması da içimi hoş etmiş oldu. Bu gönderide de Kut'un hangi eylemi nasıl gerçekleştireceğini belirleme yolu olan dinamik çözümleme -veya İngilizce olarak dynamic dispatch- hakkında yazacağım.</p>
            <p>Statik ve dinamik türleme gibi bir de elimizde statik ve dinamik çözümleme mevcut. İlkinden, önceki gönderide bahsetmiştim. Çözümleme dediğimiz problem, programın içerisindeki bir işlemin seçiminin ne zaman yapılacağı sorunudur. Statik çözümlemede bir işlev/fonksiyon ve/veya metot çağırma işleminin bizi yönlendirdiği yer derleme sırasında bellidir. Bu sistemi kullanan diller statik türlemeyi kullananlarla ciddi bir kesişime sahip: C, C++, Rust, Zig vb. Bilimum betik dilleri ve genel olarak bir yorumlayıcı tarafından yürütülen diller ya tamamen dinamik çözümlemeye sahiptir ya da dinamik çözümleme desteğine sahiptir. Aslına bakarsanız statik çözümleme, dinamik çözümleme desteği için bir engel değildir. Mesela nesne yönelimli programlamanın temel bileşenlerinden birisi olan çokbiçimlilik (polymorphism) dinamik çözümleme desteği gerektirir. Hatta C gibi tamamen prosedürel bir dil bile işlev işaretçileri üzerinden kısıtlı da olsa dinamik çözümleme desteğine sahiptir.</p>
            <p>Dinamik çözümlemede ise bir işlemin ne <em>olduğu</em> ancak program yürütülürken belli olur. Yani siz bir işlevi çağırmak istediğinizde, <em>bir şekilde</em> bu işlevin kodunun yeri çağrılma sırasında belli olur ve program, akışına oradan devam eder. Lua ve Python'daki metot çağrıları -özel optimizasyonlara sahip bir sistem üzerinde değilseniz (LuaJIT gibi)- aslında bir tabloda bu işlevin ismini arayıp, bulunan işlevi çağırmak şeklinde gerçekleşir temel olarak. Statik çözümleme olsaydı, metodun ismini yazdığınızda derleyici hangi metodu kullanacağını bulur ve uygun yönergeleri kodun içerisine yerleştirirdi. Burada ise hangi kodun çalışacağı tamamen çalışma sırasında belli oluyor. İsim bazlı olmasa da işlev işaretçileri de bize benzer bir güç verir. C'de bunların daha sofistike kullanımını görmek istiyorsanız C'deki herhangi bir nesne yönelimli programlama kütüphanesine göz atabilirsiniz.</p>
            <p>Kut'ta ben dinamik çözümlemeyi seçtim. Aslına bakarsanız bunun derleme ile çok bir ilgisi yok, zaten hâlihazırda değişken isimlerini tutma şeklim oldukça statik, bunu fonksiyonlara uyarlamak o kadar da zor olmazdı. Dinamik türlemenin statik çözümleme olan sorunları ve özellikle de esinlendiğim dil olan <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a> bu tercihimde büyük etkiye sahip oldu. Benzeri bir sistemi <a href="https://en.wikipedia.org/wiki/Objective-C">Objective-C</a> dilinde de görmek mümkün, zaten ikincisi ilkinden ciddi etkilenmiş bir dil. Smalltalk, nesne yönelimli programlamanın temel ve örnek dili diyebileceğimiz bir dil. Nesne yönelimli programlamanın tarihsel kökenine girersek, Alan Kay'in bu sistemi kafasında kurarken biyolojideki hücrelerden yararlandığına ulaşırız. Keza kendisi bir biyologdur. Nesne yönelimli programlamanın temeli de -günümüzdeki bilimum nesne yönelimli dilin biraz kaçırdığı bir temel olan- <em>mesajlaşma</em>dır. Bir "nesne" (Kay bunu hücreye veya başlı başına bir bilgisayara da benzetir) başka bir "nesne"ye bir "mesaj" yollar ve alıcı buna uygun eylemleri gerçekleştirir. Bu verici-alıcı mimarîsini genel ağda rahatça gözlemleyebiliriz. Bir istemci bir sunucuya isteğini yollar, sunucu bu isteği işler ve istemciye bir dönüt verir. Bu sırada arka planda birçok değişiklik de yapabilir elbette. Esas olan da bu mesajdır. Hatalara dirençli ve büyüdükçe karmaşıklığı baş edilemez bir hâle <em>gelmeyen</em> sistemler için nesne yönelimli programlama birebirdir.</p>
            <p>Kut'ta da bu özelliklerden faydalanmaya çalıştım. Elbette Kut'ta yazılan programların, ölçeklenebilirlikle ilgili faydaları gözlemleyebilecek kadar büyük olacağını düşünüyor değilim. Ancak hata direnci gerçekten çok çekici bir nitelik oluyor bu durumda.</p>
            <p>Kut'ta bir işlem yapmaya çalıştığınızda aslında bu, ilk baştaki değere -yani Türkçedeki özneye denk gelen varlığa-, sondaki ifadeyi mesaj olarak -yani yüklem olarak- gönderir. Bir mesaj gönderme işlemi aslında "bu mesajı yorumla ve buna uygun bir şeyler yap" anlamına geliyor. Tabii ki bu düşünce şeklinin, piyasadaki dillerdeki işlevler veya yordamlar/prosedürler ile olan birçok benzerliğinden ötürü mevzubahis nitelik gözden kaçabilir. Aradaki fark en çok, bilinmeyen bir işlem gerçekleştirilmeye çalışıldığında belli oluyor. Kut'ta temel ilkelerden birisi, eğer bir mesaj bir nesne tarafından gerçekleştirilemiyorsa "tanımsız" özel değerini dönüt olarak vermektir. Eğer bir mesajın dönüşü "tanımsız" ise bunun anlamı o nesneden, o nesnenin yapma becerisinin olmadığı bir işlemi yapmasını istediğimizdir. Birçok hata da keza bu değerin dönüt olarak verilmesi ile sonuçlanmaktadır. HTTP protokolündeki 400'lü kodların Kut karşılığı olarak düşünülebilir "tanımsız".</p>
            <p>Bütun bu mesaj gönderme meselesini gerçekleştirebilmek için de dinamik çözümleme bir bakıma <em>zorunluluk</em>tur. Bir nesneye bir mesaj gönderdiğimizde yapacağı işlem derleme zamanında bulması imkânsız olabilecek bir işlem olabilir. Evet, bütün bu tantana bu iki cümleyi söyleyebilmek içindi. Kut için dinamik çözümleme başlı başına bir tercihten ziyade, diğer tercihlerin bir sonucu oldu. Bu gönderi de sadece bu tercihi değil, genel olarak çözümleme ve işlem yapma konusunda Kut'un konumu üzerine oldu.</p>
            <p>Her ne kadar şu anda desteklemese de yakın gelecekte herhangi bir ifadenin sonucunu mesaj olarak kullanabilme desteğini Kut'a eklemeyi düşünüyorum. Bunun yanında, hâlihazırda bir nesne kendisine gönderilen mesaja göre istediği işlevi döndürebilme yetisine sahip. Mevcut nesneler her ne kadar çözümlemeyi statik bir tablo içindeki bir işlevi, mesaja göre, döndürerek yapıyor olsa da ilerideki belli başlı türlerde bu dinamiklikten faydalanmayı düşünüyorum.</p>
            <p>Bu gönderide Kut'ta neden dinamik çözümleme kullandığımdan ve Kut'ta bir işlevi çağırmanın arkasında yatan düşünce şeklinden bahsettim. Biraz da zorunluluktan ötürü ne yazık ki konudan ciddi saptığım oldu ama sonuç olarak konuyu istediğim noktaya getirebildiğime inanıyorum. Bir başka gönderide görüşmek üzere.</p>
        </div>
    </body>
</html>